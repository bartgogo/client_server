#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <fstream>
#include <zlib.h>
#include <openssl/evp.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>

// Base64编码
std::string base64_encode(const std::string& input) {
    BIO *bio, *b64;
    BUF_MEM *bufferPtr;

    b64 = BIO_new(BIO_f_base64());
    bio = BIO_new(BIO_s_mem());
    bio = BIO_push(b64, bio);

    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
    BIO_write(bio, input.c_str(), input.size());
    BIO_flush(bio);
    BIO_get_mem_ptr(bio, &bufferPtr);
    BIO_set_close(bio, BIO_NOCLOSE);

    std::string output(bufferPtr->data, bufferPtr->length);
    BIO_free_all(bio);
    return output;
}

// 计算CRC32校验码
uint32_t calculate_crc32(const std::string& data) {
    return crc32(0L, reinterpret_cast<const unsigned char*>(data.c_str()), data.size());
}

/*void send_data(SOCKET& sock, const std::string& data, bool is_file) {
    std::string encoded_data = base64_encode(data);
    uint32_t crc32_checksum = calculate_crc32(data);

    // 发送数据类型（字段数据或文件）
    char data_type = is_file ? 'F' : 'D';
    send(sock, &data_type, 1, 0);

    // 发送CRC32校验码
    send(sock, reinterpret_cast<char*>(&crc32_checksum), sizeof(crc32_checksum), 0);

    // 发送实际数据
    send(sock, encoded_data.c_str(), encoded_data.size(), 0);
}*/
// 在发送实际数据之前，发送数据长度
void send_data(SOCKET& sock, const std::string& data, bool is_file, const std::string& filename = "") {
    std::string encoded_data = base64_encode(data);
    uint32_t crc32_checksum = calculate_crc32(data);

    // 发送数据类型（字段数据或文件）
    char data_type = is_file ? 'F' : 'D';
    send(sock, &data_type, 1, 0);

    // 发送CRC32校验码
    send(sock, reinterpret_cast<char*>(&crc32_checksum), sizeof(crc32_checksum), 0);

    // 如果是文件，发送文件名长度和文件名
    if (is_file) {
        uint16_t filename_len = filename.size();
        send(sock, reinterpret_cast<char*>(&filename_len), sizeof(filename_len), 0);
        send(sock, filename.c_str(), filename_len, 0);
    }

    // 发送实际数据长度
    uint32_t data_len = encoded_data.size();
    send(sock, reinterpret_cast<char*>(&data_len), sizeof(data_len), 0);

    // 发送实际数据
    send(sock, encoded_data.c_str(), encoded_data.size(), 0);
}



void client_thread() {
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);

    SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    inet_pton(AF_INET, "121.37.136.57", &server_addr.sin_addr);

    connect(sock, (sockaddr*)&server_addr, sizeof(server_addr));

    // 用户交互
    while (true) {
        std::string input;
        std::cout << "请输入字段数据或文件路径：";
        std::getline(std::cin, input);

        if (input == "exit") {
            break;
        }

        // 判断是文件还是字段数据
        std::ifstream file(input, std::ios::binary);
        if (file) {
            // 读取文件内容
            size_t pos = input.find_last_of("/\\");
            std::string filename = (pos == std::string::npos) ? input : input.substr(pos + 1);

            std::string file_content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
            send_data(sock, file_content, true,filename);
        } else {
            // 发送字段数据
            send_data(sock, input, false);
        }
    }

    closesocket(sock);
    WSACleanup();
}

int main() {
    std::thread client(client_thread);
    client.join();
    return 0;
}
